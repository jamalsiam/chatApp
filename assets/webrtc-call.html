<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Call</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        #video-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
        }

        #remoteVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #1a1a1a;
        }

        #localVideo {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 120px;
            height: 160px;
            border-radius: 12px;
            object-fit: cover;
            border: 2px solid #fff;
            background: #2a2a2a;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            background: rgba(0,0,0,0.6);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            backdrop-filter: blur(10px);
        }

        #status.connecting { color: #FFD700; }
        #status.connected { color: #00D856; }
        #status.error { color: #FF4757; }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="video-container">
        <video id="remoteVideo" autoplay playsinline></video>
        <video id="localVideo" autoplay playsinline muted></video>
        <div id="status" class="connecting">Connecting...</div>
    </div>

    <script>
        // Default WebRTC configuration with free TURN servers
        let configuration = {
            iceServers: [
                // STUN servers
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                // Free TURN servers (Metered.ca - limited quota)
                {
                    urls: 'turn:a.relay.metered.ca:80',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                },
                {
                    urls: 'turn:a.relay.metered.ca:443',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                },
                {
                    urls: 'turn:a.relay.metered.ca:443?transport=tcp',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                }
            ]
        };

        let peerConnection = null;
        let localStream = null;
        let remoteStream = null;
        let callType = 'video'; // 'video' or 'audio'
        let isInitiator = false;
        let isScreenSharing = false;
        let originalVideoTrack = null;
        let statsInterval = null;

        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const statusDiv = document.getElementById('status');

        // Communication with React Native
        function sendMessageToRN(type, data) {
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify({ type, data }));
            }
        }

        function updateStatus(message, className = 'connecting') {
            statusDiv.textContent = message;
            statusDiv.className = className;
        }

        // Update TURN configuration
        function updateConfiguration(newConfig) {
            if (newConfig && newConfig.iceServers) {
                configuration = newConfig;
                console.log('Configuration updated:', configuration);
            }
        }

        // Initialize call
        async function initializeCall(options) {
            try {
                callType = options.callType || 'video';
                isInitiator = options.isInitiator || false;

                // Update configuration if provided
                if (options.configuration) {
                    updateConfiguration(options.configuration);
                }

                updateStatus('Getting media devices...', 'connecting');

                // Get user media
                const constraints = {
                    audio: true,
                    video: callType === 'video' ? {
                        facingMode: 'user',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    } : false
                };

                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                localVideo.srcObject = localStream;

                if (callType === 'audio') {
                    localVideo.classList.add('hidden');
                }

                updateStatus('Creating peer connection...', 'connecting');

                // Create peer connection
                peerConnection = new RTCPeerConnection(configuration);

                // Add local stream to peer connection
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                // Handle remote stream
                remoteStream = new MediaStream();
                remoteVideo.srcObject = remoteStream;

                peerConnection.ontrack = (event) => {
                    event.streams[0].getTracks().forEach(track => {
                        remoteStream.addTrack(track);
                    });
                    updateStatus('Connected', 'connected');
                };

                // Handle ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        sendMessageToRN('iceCandidate', event.candidate);
                    }
                };

                // Handle connection state changes
                peerConnection.onconnectionstatechange = () => {
                    const state = peerConnection.connectionState;
                    console.log('Connection state:', state);

                    if (state === 'connected') {
                        updateStatus('Connected', 'connected');
                        // Start call quality monitoring
                        startQualityMonitoring();
                    } else if (state === 'failed' || state === 'disconnected') {
                        updateStatus('Connection lost', 'error');
                        stopQualityMonitoring();
                        sendMessageToRN('connectionError', { state });
                    }
                };

                // If initiator, create offer
                if (isInitiator) {
                    updateStatus('Creating offer...', 'connecting');
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    sendMessageToRN('offer', offer);
                }

                sendMessageToRN('initialized', { success: true });
            } catch (error) {
                console.error('Error initializing call:', error);
                updateStatus('Failed to start call', 'error');
                sendMessageToRN('error', { message: error.message });
            }
        }

        // Handle offer from remote peer
        async function handleOffer(offer) {
            try {
                updateStatus('Receiving call...', 'connecting');
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                sendMessageToRN('answer', answer);
            } catch (error) {
                console.error('Error handling offer:', error);
                sendMessageToRN('error', { message: error.message });
            }
        }

        // Handle answer from remote peer
        async function handleAnswer(answer) {
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                updateStatus('Connecting...', 'connecting');
            } catch (error) {
                console.error('Error handling answer:', error);
                sendMessageToRN('error', { message: error.message });
            }
        }

        // Handle ICE candidate from remote peer
        async function handleIceCandidate(candidate) {
            try {
                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            } catch (error) {
                console.error('Error adding ICE candidate:', error);
            }
        }

        // Toggle camera
        function toggleCamera() {
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) {
                    videoTrack.enabled = !videoTrack.enabled;
                    sendMessageToRN('cameraToggled', { enabled: videoTrack.enabled });
                    return videoTrack.enabled;
                }
            }
            return false;
        }

        // Toggle microphone
        function toggleMicrophone() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = !audioTrack.enabled;
                    sendMessageToRN('microphoneToggled', { enabled: audioTrack.enabled });
                    return audioTrack.enabled;
                }
            }
            return false;
        }

        // Switch camera (front/back)
        async function switchCamera() {
            if (localStream && callType === 'video') {
                const videoTrack = localStream.getVideoTracks()[0];
                const currentFacingMode = videoTrack.getSettings().facingMode;
                const newFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';

                try {
                    const newStream = await navigator.mediaDevices.getUserMedia({
                        audio: true,
                        video: { facingMode: newFacingMode }
                    });

                    const newVideoTrack = newStream.getVideoTracks()[0];
                    const sender = peerConnection.getSenders().find(s => s.track.kind === 'video');

                    if (sender) {
                        sender.replaceTrack(newVideoTrack);
                    }

                    videoTrack.stop();
                    localStream.removeTrack(videoTrack);
                    localStream.addTrack(newVideoTrack);
                    localVideo.srcObject = localStream;

                    sendMessageToRN('cameraSwitched', { facingMode: newFacingMode });
                } catch (error) {
                    console.error('Error switching camera:', error);
                    sendMessageToRN('error', { message: 'Failed to switch camera' });
                }
            }
        }

        // Start screen sharing
        async function startScreenSharing() {
            try {
                if (!peerConnection || isScreenSharing) return;

                // Get screen capture stream
                const screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        cursor: 'always'
                    },
                    audio: false
                });

                const screenTrack = screenStream.getVideoTracks()[0];

                // Store original video track
                if (localStream) {
                    originalVideoTrack = localStream.getVideoTracks()[0];
                }

                // Replace video track with screen track
                const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
                if (sender) {
                    await sender.replaceTrack(screenTrack);
                }

                // Update local video
                localVideo.srcObject = screenStream;
                isScreenSharing = true;

                // Handle screen share ended
                screenTrack.onended = () => {
                    stopScreenSharing();
                };

                sendMessageToRN('screenSharingStarted', { success: true });
            } catch (error) {
                console.error('Error starting screen share:', error);
                sendMessageToRN('error', { message: 'Failed to start screen sharing' });
            }
        }

        // Stop screen sharing
        async function stopScreenSharing() {
            try {
                if (!isScreenSharing || !originalVideoTrack) return;

                // Replace screen track with original video track
                const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
                if (sender) {
                    await sender.replaceTrack(originalVideoTrack);
                }

                // Restore local video
                localVideo.srcObject = localStream;
                isScreenSharing = false;

                sendMessageToRN('screenSharingStopped', { success: true });
            } catch (error) {
                console.error('Error stopping screen share:', error);
            }
        }

        // Call quality monitoring
        function startQualityMonitoring() {
            if (statsInterval) return;

            statsInterval = setInterval(async () => {
                if (!peerConnection) return;

                try {
                    const stats = await peerConnection.getStats(null);
                    const qualityData = parseStats(stats);
                    sendMessageToRN('callQuality', qualityData);
                } catch (error) {
                    console.error('Error getting stats:', error);
                }
            }, 2000); // Update every 2 seconds
        }

        function stopQualityMonitoring() {
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
        }

        function parseStats(stats) {
            let qualityData = {
                bitrate: 0,
                packetsLost: 0,
                jitter: 0,
                roundTripTime: 0,
                quality: 'good' // good, fair, poor
            };

            stats.forEach(report => {
                if (report.type === 'inbound-rtp' && report.kind === 'video') {
                    qualityData.packetsLost = report.packetsLost || 0;
                    qualityData.jitter = report.jitter || 0;
                    qualityData.bitrate = report.bytesReceived || 0;
                } else if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                    qualityData.roundTripTime = report.currentRoundTripTime || 0;
                }
            });

            // Determine quality level
            if (qualityData.packetsLost > 50 || qualityData.roundTripTime > 0.3) {
                qualityData.quality = 'poor';
            } else if (qualityData.packetsLost > 20 || qualityData.roundTripTime > 0.15) {
                qualityData.quality = 'fair';
            }

            return qualityData;
        }

        // End call
        function endCall() {
            stopQualityMonitoring();

            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            if (peerConnection) {
                peerConnection.close();
            }
            sendMessageToRN('callEnded', {});
        }

        // Listen for messages from React Native
        window.addEventListener('message', (event) => {
            try {
                const message = JSON.parse(event.data);

                switch (message.type) {
                    case 'initialize':
                        initializeCall(message.data);
                        break;
                    case 'offer':
                        handleOffer(message.data);
                        break;
                    case 'answer':
                        handleAnswer(message.data);
                        break;
                    case 'iceCandidate':
                        handleIceCandidate(message.data);
                        break;
                    case 'toggleCamera':
                        toggleCamera();
                        break;
                    case 'toggleMicrophone':
                        toggleMicrophone();
                        break;
                    case 'switchCamera':
                        switchCamera();
                        break;
                    case 'startScreenSharing':
                        startScreenSharing();
                        break;
                    case 'stopScreenSharing':
                        stopScreenSharing();
                        break;
                    case 'updateConfiguration':
                        updateConfiguration(message.data);
                        break;
                    case 'endCall':
                        endCall();
                        break;
                }
            } catch (error) {
                console.error('Error processing message:', error);
            }
        });

        // Notify React Native that WebView is ready
        sendMessageToRN('ready', {});
    </script>
</body>
</html>
